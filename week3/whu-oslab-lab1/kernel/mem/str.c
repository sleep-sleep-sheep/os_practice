#include "common.h"

/*
  内存初始化函数：
    将 dst 指向的内存区域的前 n 个字节设置为值 c
    参数：
        dst：目标内存区域的起始地址
        c：要设置的字节值（按字节处理，取低8位）
        n：要设置的字节数
*/
void *memset(void *dst, int c, uint32 n) {
    char *cdst=(char*)dst;//转换为char*类型，按字节操作
    for(uint32 i=0;i<n;i++)
        cdst[i]=c;
    return dst;
}


/*
    内存比较函数：
        比较内存区域 v1 和 v2 的前 n 个字节
    参数：
        v1：第一个内存区域的起始地址
        v2：第二个内存区域的起始地址
        n：要比较的字节数   
*/
int memcmp(const void *v1, const void *v2, uint32 n) {
    const unsigned char *s1=v1, *s2=v2;
    for(uint32 i=0;i<n;i++){
        if(s1[i]!=s2[i])
            return s1[i]-s2[i];
    }
    return 0;
}


/*
    内存移动函数：
        将内存区域 src 的前 n 个字节复制到内存区域 dst
        处理内存重叠的情况，确保正确复制
    参数：
        dst：目标内存区域的起始地址
        src：源内存区域的起始地址
        n：要复制的字节数
*/
void*
memmove(void *dst, const void *src, uint32 n)
{
  const char *s;  // 源内存块的字符指针（const确保不修改源数据）
  char *d;        // 目标内存块的字符指针

  if(n == 0)              // 若复制字节数为0，直接返回
    return dst;
  
  s = src;                // 转换源地址为char*
  d = dst;                // 转换目标地址为char*
  // 判断源地址和目标地址是否重叠：源在目标前面且源结束地址超过目标起始地址
  if(s < d && s + n > d){
    s += n;               // 源指针移动到末尾
    d += n;               // 目标指针移动到末尾
    while(n-- > 0)        // 从后往前复制，避免覆盖未复制的源数据
      *--d = *--s;        // 先移动指针再赋值（--d指向当前要填充的位置）
  } else                  // 无重叠或源在目标后面，直接从前往后复制
    while(n-- > 0)
      *d++ = *s++;        // 先赋值再移动指针

  return dst;             // 返回目标地址
}


/*
    内存复制函数：
        将内存区域 src 的前 n 个字节复制到内存区域 dst
        该函数调用 memmove 以处理可能的重叠情况
    参数：
        dst：目标内存区域的起始地址
        src：源内存区域的起始地址
        n：要复制的字节数
*/
void *memcpy(void *dst, const void *src, uint32 n) {
    return memmove(dst, src, n);
}




// 字符串比较函数：比较两个字符串的前n个字符（或直到遇到结束符）
// 参数：
//   p - 第一个字符串
//   q - 第二个字符串
//   n - 最大比较长度
// 返回值：
//   正数：p中第一个不同字符大于q中对应字符
//   负数：p中第一个不同字符小于q中对应字符
//   0：两个字符串前n个字符或到结束符前完全相同
int
strncmp(const char *p, const char *q, uint32 n)
{
  // 循环条件：还有比较次数(n>0)、两个字符串都未结束(*p和*q非0)、当前字符相等
  while(n > 0 && *p && *p == *q)
    n--, p++, q++;  // 减少比较次数，移动两个字符串指针
  if(n == 0)        // 若已比较完n个字符，返回0
    return 0;
  // 否则返回两个字符的差值（转换为uchar避免符号问题）
  return (uint8)*p - (uint8)*q;
}




// 字符串复制函数：将源字符串复制到目标缓冲区（最多n个字符）
// 参数：
//   s - 目标缓冲区
//   t - 源字符串
//   n - 最大复制字符数（包括填充的空字符）
// 返回值：目标缓冲区的起始地址
// 注意：若源字符串长度>=n，结果可能没有空结尾
char*
strncpy(char *s, const char *t, int n)
{
  char *os;  // 保存目标缓冲区的起始地址（用于返回）

  os = s;    // 记录起始地址
  // 复制字符：直到n减为0或源字符串结束（遇到'\0'）
  while(n-- > 0 && (*s++ = *t++) != 0)
    ;  // 循环体为空，操作在条件中完成
  // 若还有剩余空间（n>0），用'\0'填充剩余位置
  while(n-- > 0)
    *s++ = 0;
  return os;  // 返回目标缓冲区起始地址
}



// 安全字符串复制函数：类似strncpy但保证目标字符串以空字符结尾
// 参数：
//   s - 目标缓冲区
//   t - 源字符串
//   n - 目标缓冲区大小（必须>=1，否则无法存储空字符）
// 返回值：目标缓冲区的起始地址
char*
safestrcpy(char *s, const char *t, int n)
{
  char *os;  // 保存目标缓冲区的起始地址

  os = s;    // 记录起始地址
  if(n <= 0)  // 若缓冲区大小<=0，直接返回（无法存储任何字符）
    return os;
  // 最多复制n-1个字符（留一个位置给空字符），直到源字符串结束
  while(--n > 0 && (*s++ = *t++) != 0)
    ;  // 循环体为空，操作在条件中完成
  *s = 0;    // 强制添加空字符结尾，确保字符串有效
  return os;  // 返回目标缓冲区起始地址
}



// 字符串长度函数：计算字符串的长度（不包括结尾的空字符）
// 参数：s - 要计算长度的字符串
// 返回值：字符串中字符的数量（空字符前的字符数）
int
strlen(const char *s)
{
  int n;  // 长度计数器

  for(n = 0; s[n]; n++)  // 遍历字符串，直到遇到空字符'\0'（s[n]为0时终止）
    ;  // 循环体为空，n在条件中自增
  return n;  // 返回计数器值（即字符串长度）
}
